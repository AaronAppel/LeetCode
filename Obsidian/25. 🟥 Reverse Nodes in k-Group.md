https://leetcode.com/problems/
ðŸŸ¥Hard

Given theÂ `head`Â of a linked list, reverse the nodes of the listÂ `k`Â at a time, and returnÂ _the modified list_.

`k`Â is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple ofÂ `k`Â then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

**Input:** head = [1,2,3,4,5], k = 2
**Output:** [2,1,4,3,5]

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

**Input:** head = [1,2,3,4,5], k = 3
**Output:** [3,2,1,4,5]

**Constraints:**

- The number of nodes in the list isÂ `n`.
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**Follow-up:**Â Can you solve the problem inÂ `O(1)`Â extra memory space?

---

My Final Solution :
```cpp live:true sym:"" file:"25.ReverseNodesInKGroup.cpp"

#include <assert.h>
#include <string>
#include <vector>

// https://leetcode.com/problems/merge-k-sorted-lists/

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* ReverseNodesInKGroup_v1(ListNode* lists, int k)
{
	return nullptr;
}

#include "Testing.h"
typedef ListNode*(*SolutionFuncPtr)(ListNode*, int);

void main_ReverseNodesInKGroup()
{
	SolutionFuncPtr solutionFunc = ReverseNodesInKGroup_v1;

	// LeetCode cases
	assert(solutionFunc(nullptr, 0) == nullptr);

	// My cases
	// assert(solutionFunc() == true);

	// Test solution performance
	std::vector<SolutionFuncPtr> funcs = {
		ReverseNodesInKGroup_v1,
	};

	RunSolutions(funcs, nullptr, nullptr);

	int bp = 0;
}

// int main() { main_ReverseNodesInKGroup(); }


#include <assert.h>
#include <string>
#include <vector>

// https://leetcode.com/problems/merge-k-sorted-lists/

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* ReverseNodesInKGroup_v1(ListNode* lists, int k)
{
	return nullptr;
}

#include "Testing.h"
typedef ListNode*(*SolutionFuncPtr)(ListNode*, int);

void main_ReverseNodesInKGroup()
{
	SolutionFuncPtr solutionFunc = ReverseNodesInKGroup_v1;

	// LeetCode cases
	assert(solutionFunc(nullptr, 0) == nullptr);

	// My cases
	// assert(solutionFunc() == true);

	// Test solution performance
	std::vector<SolutionFuncPtr> funcs = {
		ReverseNodesInKGroup_v1,
	};

	RunSolutions(funcs, nullptr, nullptr);

	int bp = 0;
}

// int main() { main_ReverseNodesInKGroup(); }

```
#### Notes :
