https://leetcode.com/problems/longest-common-prefix/
ðŸŸ©Easy

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty stringÂ `""`.

**Example 1:**

**Input:** strs = ["flower","flow","flight"]
**Output:** "fl"

**Example 2:**

**Input:** strs = ["dog","racecar","car"]
**Output:** ""
**Explanation:** There is no common prefix among the input strings.

**Constraints:**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]`Â consists of only lowercase English letters if it is non-empty.

---

My Final Solution :
```cpp live:true file:"14.LongestCommonPrefix.cpp"
std::string LongestCommonPrefix_v1(const std::vector<std::string>& strings)
{
	// #NOTE Naive solution

	if (strings.size() == 0)
		return "";

	std::string longestPrefix = strings[0];

	for (size_t i = 1; i < strings.size(); i++)
	{
		if (longestPrefix.size() > strings[i].size())
		{
			longestPrefix = longestPrefix.substr(0, strings[i].size());
		}

		unsigned int shorterLength = strings[i].size() < longestPrefix.size() ? strings[i].size() : longestPrefix.size();
		for (size_t j = 0; j < shorterLength; j++)
		{
			if (longestPrefix[j] != strings[i][j])
			{
				if (j < longestPrefix.size())
				{
					longestPrefix = longestPrefix.substr(0, j);
				}
				break;
			}
		}

		if (longestPrefix.size() == 0)
		{
			return "";
		}
	}

	return longestPrefix;
}
```
#### Notes :
I found this one confusing at first since it wasn't explicitly stated that all strings in the array MUST have a matching prefix. I thought an empty string could exist and still return prefixes shared by other values, but then it would be possible to have other prefixes also be valid so I understand the reasoning now.

Interesting note while reviewing, I found that the longestPrefix\[j\] index was out of bounds, but wasn't causing exceptions. The initial capacity was 15 so index access for small values were still within allocated memory, and were being compared to garbage values and returning correctly. I tried testing longestPrefix\[10000\] and then I got an exception but I added a min() style check by adding shorterLength variable to prevent out of bounds string char array access.