https://leetcode.com/problems/container-with-most-water/description/
ðŸŸ¨Difficulty

You are given an integer arrayÂ `height`Â of lengthÂ `n`. There areÂ `n`Â vertical lines drawn such that the two endpoints of theÂ `ith`Â line areÂ `(i, 0)`Â andÂ `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

ReturnÂ _the maximum amount of water a container can store_.

**Notice**Â that you may not slant the container.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

**Input:** height = [1,8,6,2,5,4,8,3,7]
**Output:** 49
**Explanation:** The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

**Example 2:**

**Input:** height = [1,1]
**Output:** 1

**Constraints:**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

---

My Final Solution :
```cpp
int ContainerWithMostWater_v3(const std::vector<int>& height)
{
	// #NOTE 2 pointers approach

	unsigned int greatestVolume = 0;

	unsigned lowerIndex = 0;
	unsigned upperIndex = height.size() - 1;

	while (lowerIndex < upperIndex)
	{
		const unsigned int shorterLineHeight = height[lowerIndex] < height[upperIndex] ? height[lowerIndex] : height[upperIndex];
		const unsigned int distanceBetweenLines = upperIndex - lowerIndex;
		const unsigned int currentVolume = shorterLineHeight * distanceBetweenLines;

		if (currentVolume > greatestVolume)
		{
			greatestVolume = currentVolume;
		}

		if (height[lowerIndex] < height[upperIndex])
		{
			++lowerIndex;
		}
		else
		{
			--upperIndex;
		}
	}

	return greatestVolume;
}
```
#### Notes :
So the naive solution, using n\*n complexity was pretty straight forward as far as implementation. Of course it scales extremely poorly but without further understanding of the problem it's hard to optimize.

Solution \#2 was an attempt to find early returns and checks to reduce the number or iteration by continuing in the outer foor loop. Some efficiency was gained, although it is still an added check to do each time the outer loop returns.

Finally for solution \#3 I can see where "trick" was, using a classic 2 pointers or "sliding window" approach. As per all optimizations, once we can make the right assumptions then we can eliminate more cases without introducing bugs with edge cases. Starting from the outside and moving in means the distance between lines decreases, so all future comparisons are guaranteed to have shorter distances. If we move the pointer for the shorter line, we should always end up comparing the two tallest lines, which will result in the largest area, or water in this case.

Another interesting application for the 2 pointers, sliding window approach to searching. Also another great exercise for sniffing out optimizations through assumptions.